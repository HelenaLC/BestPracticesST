# Neighborhood analysis

## Dependencies

```{r deps, message=FALSE, warning=FALSE}
library(RANN)
library(dplyr)
library(ggplot2)
library(SpatialExperiment)
# load data from previous section
spe <- readRDS("img-spe_cl.rds")
```

## Spatial contexts

Spatial niche analysis aims at identifying regions of homogeneous composition by grouping cells based on their microenvironment.
To this end, methods such as `r BiocStyle::Biocpkg("imcRtools")` [@Windhager2023-imcRtools] and `r BiocStyle::Biocpkg("concordexR")` [@Jackson2024-concordex] rely on a $k$-nearest-neighbor ($k$NN) graph (based on Euclidean cell-to-cell distances), and clustering cells using common clustering algorithms (according to their neighborhood's subpopulation frequencies).

## Co-localization

`r BiocStyle::Biocpkg("hoodscanR")` also relies on a cell-level $k$NN graph, but performs a permutation test to obtain cell-level probabilities of association with its neighbors.
These can, in turn, be used to assess co-occurrence of subpopulations. 

## Nearest neighbors

Various spatial analyses rely on identifying nearest neighbors (NNs) of cells.
We recommend `r BiocStyle::CRANpkg("RANN")` for this purpose, which finds NNs in **$O(N\log N)$ time for $N$ cells** (c.f., conventional approaches would take $O(N^2)$ time) by relying on a Approximate Near Neighbor (ANN) C++ library.
Furthermore, there is support for **exact, approximate, and fixed-radius searchers**.
The latter is of particular interest in biology; e.g., one might require $k$NNs to lie within a biologically sensible distance as to avoid consideration of cells that are far-off, especially in sparse regions or at tissue borders.

As a toy example, we here compute the $k$NNs with and without fixed radius, and compare neighborhood subpopulation compositions between both approaches:

```{r eval=FALSE}
cs <- seq(ncol(spe))
cs_k <- split(cs, spe$k)
xy <- spatialCoords(spe)
ns <- lapply(names(cs_k), \(k) {
    j <- setdiff(cs, i <- cs_k[[k]])
    nns <- nn2(xy[j, ], xy[i, ], k=(k <- 10))
    idx <- nns$nn.idx[, -1]
    data.frame(i=rep(i, each=k-1), j=c(idx))
}) |> 
    do.call(what=rbind) |>
    mutate(k1=spe$k[i], k2=spe$k[j]) 
nc <- unclass(table(spe$k))
fq <- ns |> 
    group_by(k1) |>
    mutate(p=n/nc[k2])
ggplot(fq, aes(k1, k2, fill=p)) +
    geom_tile() +
    coord_equal(expand=FALSE) +
    scale_fill_gradientn(colors=c("ivory", "navy"))
```

## References {.unnumbered}
